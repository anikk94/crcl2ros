<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CRCL APP: RCS Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CRCL APP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">RCS Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace Conversion provides some utilities to convert from one representation into another. Representations include tf, Eigen::Affine3d, std::vector, geometry_msgs::Pose, geometry_msgs::Point, and CRCL.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CanonAccProfile.html">CanonAccProfile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration of trajectory acceleration profile.  <a href="structRCS_1_1CanonAccProfile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CanonAngleUnit.html">CanonAngleUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration of angle units. Conversion into ROS compatible radians.  <a href="structRCS_1_1CanonAngleUnit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CanonCmdType.html">CanonCmdType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration of <a class="el" href="namespaceCrcl.html">Crcl</a> commands. Many <a class="el" href="namespaceCrcl.html">Crcl</a> commands are wm parameter setting and require no motion component.  <a href="structRCS_1_1CanonCmdType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CanonControlType.html">CanonControlType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CanonForceUnit.html">CanonForceUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration of force units.  <a href="structRCS_1_1CanonForceUnit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CanonLengthUnit.html">CanonLengthUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration of length units. Conversion into ROS compatible meters.  <a href="structRCS_1_1CanonLengthUnit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CanonReturn.html">CanonReturn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration of return type from <a class="el" href="namespaceCrcl.html">Crcl</a> intepretation. If statusreply, requires status sent to <a class="el" href="namespaceCrcl.html">Crcl</a> client.  <a href="structRCS_1_1CanonReturn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CanonStatusType.html">CanonStatusType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration of controller status types for individual commands. Note, even though command types are listed, not all used or supported.  <a href="structRCS_1_1CanonStatusType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CanonStopMotionType.html">CanonStopMotionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration of stopping motion, e.g., estop equivalent to immediate.  <a href="structRCS_1_1CanonStopMotionType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CanonTorqueUnit.html">CanonTorqueUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumerati_nextccon of torque units.  <a href="structRCS_1_1CanonTorqueUnit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CCanonCmd.html">CCanonCmd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CanonCmd is the controller command structure.  <a href="structRCS_1_1CCanonCmd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1CCanonWorldModel.html">CCanonWorldModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CanonWorldModel describes the controller state. Includes reference to robot model.  <a href="structRCS_1_1CCanonWorldModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRCS_1_1CComandLineInterface.html">CComandLineInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CLI class provides a simple command line interface through a Linux console. It is primitive in that there are no "modern" console features. It does offer an interactive way to test the robot to see if things are working or why they are failing. Commands:  <a href="classRCS_1_1CComandLineInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRCS_1_1CMessageQueue.html">CMessageQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classRCS_1_1CMessageQueue.html" title="The CMessageQueue offers a mutexed front end to a STL/std deque. The queue is a LIFO data structure...">CMessageQueue</a> offers a mutexed front end to a STL/std deque. The queue is a LIFO data structure. Useful for safely sharing data between multiple threads.  <a href="classRCS_1_1CMessageQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRCS_1_1CMsgQueueThread.html">CMsgQueueThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRCS_1_1CMsgQueueThread.html" title="CMsgQueueThread is a message queued thread. It is activated when a message is received.   Notes: http://stackoverflow.com/questions/768351/complete-example-using-boostsignals-for-c-eventing. ">CMsgQueueThread</a> is a message queued thread. It is activated when a message is received. <br />
 Notes: <a href="http://stackoverflow.com/questions/768351/complete-example-using-boostsignals-for-c-eventing">http://stackoverflow.com/questions/768351/complete-example-using-boostsignals-for-c-eventing</a>.  <a href="classRCS_1_1CMsgQueueThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1compareCrclId.html">compareCrclId</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRCS_1_1CPriorityMessageQueue.html">CPriorityMessageQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classRCS_1_1CMessageQueue.html" title="The CMessageQueue offers a mutexed front end to a STL/std deque. The queue is a LIFO data structure...">CMessageQueue</a> offers a mutexed front to a STL/std deque. The queue is a LIFO data structure. Useful for safely sharing data between multiple threads.  <a href="classRCS_1_1CPriorityMessageQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRCS_1_1IRate.html">IRate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRCS_1_1IRate.html" title="IRate is an interface class for defining the allowed motion rates. ">IRate</a> is an interface class for defining the allowed motion rates.  <a href="classRCS_1_1IRate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRCS_1_1IRCSInterpreter.html">IRCSInterpreter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IInterpreter parses a <a class="el" href="namespaceRCS.html" title="The namespace Conversion provides some utilities to convert from one representation into another...">RCS</a> command and generates robot motion commands.  <a href="classRCS_1_1IRCSInterpreter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1MovementType.html">MovementType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration of trajectory motion type, joint or cartesian.  <a href="structRCS_1_1MovementType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1PoseTolerance.html">PoseTolerance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRCS_1_1Thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRCS_1_1Thread.html" title="Thread is an RCS ulapi equivalent for a timed thread. Given a cycle time, the thread provides a wait ...">Thread</a> is an <a class="el" href="namespaceRCS.html" title="The namespace Conversion provides some utilities to convert from one representation into another...">RCS</a> ulapi equivalent for a timed thread. Given a cycle time, the thread provides a wait function to sleep to exactly the amount of the thread cycle time. It keeps track of busy/idle time for diagnostic purposes. <br />
 Notes: <a href="https://www.quantnet.com/threads/c-multithreading-in-boost.10028/">https://www.quantnet.com/threads/c-multithreading-in-boost.10028/</a>.  <a href="classRCS_1_1Thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRCS_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRCS_1_1Timer.html" title="Timer is a general-purpose timer. The Timer is a general-purpose timer, which can be used for waiting...">Timer</a> is a general-purpose timer. The <a class="el" href="classRCS_1_1Timer.html" title="Timer is a general-purpose timer. The Timer is a general-purpose timer, which can be used for waiting...">Timer</a> is a general-purpose timer, which can be used for waiting until a synchronous time tick, sleep for any period at all, or to obtain a time in system clock ticks from creation of the timer.  <a href="classRCS_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRCS_1_1TrajPointType.html">TrajPointType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration of trajectory pose points.  <a href="structRCS_1_1TrajPointType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7bc73372e6a89bb37b562bdd72cf3a6e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classRCS_1_1CPriorityMessageQueue.html">RCS::CPriorityMessageQueue</a>&lt; <a class="el" href="structcrcl__rosmsgs_1_1CrclCommandMsg.html">crcl_rosmsgs::CrclCommandMsg</a>, <a class="el" href="structRCS_1_1compareCrclId.html">RCS::compareCrclId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a7bc73372e6a89bb37b562bdd72cf3a6e">CrclMessageQueue</a></td></tr>
<tr class="separator:a7bc73372e6a89bb37b562bdd72cf3a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c220bdfe1b529b0925d3c9d443b7c6"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a01c220bdfe1b529b0925d3c9d443b7c6">RCS_TIMERFUNC</a>) (void *_arg)</td></tr>
<tr class="separator:a01c220bdfe1b529b0925d3c9d443b7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161197f1bc13b855025b237801dea8eb"><td class="memItemLeft" align="right" valign="top">typedef std::chrono::high_resolution_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a161197f1bc13b855025b237801dea8eb">RCS_Time</a></td></tr>
<tr class="separator:a161197f1bc13b855025b237801dea8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac696d9ef9c4058c180c13bdb3a867118"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac696d9ef9c4058c180c13bdb3a867118"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#ac696d9ef9c4058c180c13bdb3a867118">ToVector</a> (int n,...)</td></tr>
<tr class="memdesc:ac696d9ef9c4058c180c13bdb3a867118"><td class="mdescLeft">&#160;</td><td class="mdescRight">ToVector calling parameters MUST match e.g., double or long depending on template, OR wont work.  <a href="#ac696d9ef9c4058c180c13bdb3a867118">More...</a><br /></td></tr>
<tr class="separator:ac696d9ef9c4058c180c13bdb3a867118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606c365be7883a31a4dbf241b3e0c0a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a606c365be7883a31a4dbf241b3e0c0a8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a606c365be7883a31a4dbf241b3e0c0a8">ScaleVector</a> (std::vector&lt; T &gt; goaljts, double multiplier=M_PI/180.0)</td></tr>
<tr class="memdesc:a606c365be7883a31a4dbf241b3e0c0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of std vector type T from degrees to radians Change template from typep into double conversion factor. you can't use float literals as template parameters.  <a href="#a606c365be7883a31a4dbf241b3e0c0a8">More...</a><br /></td></tr>
<tr class="separator:a606c365be7883a31a4dbf241b3e0c0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f28269c28731c0ebdb78bb23fa428a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84f28269c28731c0ebdb78bb23fa428a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a84f28269c28731c0ebdb78bb23fa428a">ToRadianVector</a> (std::vector&lt; T &gt; goaljts)</td></tr>
<tr class="memdesc:a84f28269c28731c0ebdb78bb23fa428a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of std vector type T from degrees to radians Change template from typep into double conversion factor. you can't use float literals as template parameters.  <a href="#a84f28269c28731c0ebdb78bb23fa428a">More...</a><br /></td></tr>
<tr class="separator:a84f28269c28731c0ebdb78bb23fa428a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c180fb111c739f218802a66eb6b2c3"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:ac7c180fb111c739f218802a66eb6b2c3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#ac7c180fb111c739f218802a66eb6b2c3">ConvertStringVector</a> (std::vector&lt; std::string &gt; From)</td></tr>
<tr class="memdesc:ac7c180fb111c739f218802a66eb6b2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of std vector type string into a vector of doubles.  <a href="#ac7c180fb111c739f218802a66eb6b2c3">More...</a><br /></td></tr>
<tr class="separator:ac7c180fb111c739f218802a66eb6b2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ac16f6e009553aa5f363a3c3949861"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:a37ac16f6e009553aa5f363a3c3949861"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">Convert</a> (From f)</td></tr>
<tr class="memdesc:a37ac16f6e009553aa5f363a3c3949861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty conversion of type from into type to. If called, asserts.  <a href="#a37ac16f6e009553aa5f363a3c3949861">More...</a><br /></td></tr>
<tr class="separator:a37ac16f6e009553aa5f363a3c3949861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d6e450ecf2c5116230ae386a2c9ad5"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab4d6e450ecf2c5116230ae386a2c9ad5"><td class="memTemplItemLeft" align="right" valign="top">tf::Pose&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#ab4d6e450ecf2c5116230ae386a2c9ad5">Convert&lt; geometry_msgs::Pose, tf::Pose &gt;</a> (geometry_msgs::Pose m)</td></tr>
<tr class="memdesc:ab4d6e450ecf2c5116230ae386a2c9ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geometry_msgs::Pose into tf::Pose.  <a href="#ab4d6e450ecf2c5116230ae386a2c9ad5">More...</a><br /></td></tr>
<tr class="separator:ab4d6e450ecf2c5116230ae386a2c9ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaeace0f93a957fe258b4b2ba64c3062"><td class="memItemLeft" align="right" valign="top">tf::Pose&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#aeaeace0f93a957fe258b4b2ba64c3062">ConvertDblVectorTf</a> (std::vector&lt; double &gt; ds)</td></tr>
<tr class="separator:aeaeace0f93a957fe258b4b2ba64c3062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e75302cbdd498437aaadbb62d451d17"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7e75302cbdd498437aaadbb62d451d17"><td class="memTemplItemLeft" align="right" valign="top">tf::Pose&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a7e75302cbdd498437aaadbb62d451d17">Convert&lt; tf::Quaternion, tf::Pose &gt;</a> (tf::Quaternion q)</td></tr>
<tr class="memdesc:a7e75302cbdd498437aaadbb62d451d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert tf::Quaternion into tf::Pose.  <a href="#a7e75302cbdd498437aaadbb62d451d17">More...</a><br /></td></tr>
<tr class="separator:a7e75302cbdd498437aaadbb62d451d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8beb14a607d0761435e21f8aaae004"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7f8beb14a607d0761435e21f8aaae004"><td class="memTemplItemLeft" align="right" valign="top">tf::Pose&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a7f8beb14a607d0761435e21f8aaae004">Convert&lt; tf::Vector3, tf::Pose &gt;</a> (tf::Vector3 t)</td></tr>
<tr class="memdesc:a7f8beb14a607d0761435e21f8aaae004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert tf::Vector3 into tf::Pose.  <a href="#a7f8beb14a607d0761435e21f8aaae004">More...</a><br /></td></tr>
<tr class="separator:a7f8beb14a607d0761435e21f8aaae004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1d0e845c7aca5f94ee9ef547cd312d"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:adb1d0e845c7aca5f94ee9ef547cd312d"><td class="memTemplItemLeft" align="right" valign="top">tf::Vector3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#adb1d0e845c7aca5f94ee9ef547cd312d">Convert&lt; tf::Pose, tf::Vector3 &gt;</a> (tf::Pose t)</td></tr>
<tr class="memdesc:adb1d0e845c7aca5f94ee9ef547cd312d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert tf::Pose into tf::Vector3.  <a href="#adb1d0e845c7aca5f94ee9ef547cd312d">More...</a><br /></td></tr>
<tr class="separator:adb1d0e845c7aca5f94ee9ef547cd312d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647347930fde84748762563d582075fb"><td class="memItemLeft" align="right" valign="top">tf::Pose&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a647347930fde84748762563d582075fb">CreateRPYPose</a> (std::vector&lt; double &gt; ds)</td></tr>
<tr class="memdesc:a647347930fde84748762563d582075fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">CreateRPYPose taks array of double and create a tf::Pose.  <a href="#a647347930fde84748762563d582075fb">More...</a><br /></td></tr>
<tr class="separator:a647347930fde84748762563d582075fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6153c96ec882b3eeb738088b41d42aee"><td class="memItemLeft" align="right" valign="top">tf::Quaternion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a6153c96ec882b3eeb738088b41d42aee">Rpy2Quaternion</a> (double roll, double pitch, double yaw)</td></tr>
<tr class="separator:a6153c96ec882b3eeb738088b41d42aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759bab14f332371a1810654242cf3f2c"><td class="memItemLeft" align="right" valign="top">tf::Pose&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a759bab14f332371a1810654242cf3f2c">CreatePose</a> (tf::Vector3 axis, double angle)</td></tr>
<tr class="memdesc:a759bab14f332371a1810654242cf3f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Pose from a axis and angle rotation representation.  <a href="#a759bab14f332371a1810654242cf3f2c">More...</a><br /></td></tr>
<tr class="separator:a759bab14f332371a1810654242cf3f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5e15676de18c49b48ed17eebe80339"><td class="memItemLeft" align="right" valign="top">tf::Quaternion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#acf5e15676de18c49b48ed17eebe80339">RPYRadians</a> (double roll, double pitch, double yaw)</td></tr>
<tr class="memdesc:acf5e15676de18c49b48ed17eebe80339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Quaternion from a rpy rotation representation designated in radians.  <a href="#acf5e15676de18c49b48ed17eebe80339">More...</a><br /></td></tr>
<tr class="separator:acf5e15676de18c49b48ed17eebe80339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3e828a1b253f67f45e714c4784b379"><td class="memItemLeft" align="right" valign="top">tf::Quaternion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a6c3e828a1b253f67f45e714c4784b379">RPYDegrees</a> (double roll, double pitch, double yaw)</td></tr>
<tr class="memdesc:a6c3e828a1b253f67f45e714c4784b379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Quaternion from a rpy rotation representation designated in degrees.  <a href="#a6c3e828a1b253f67f45e714c4784b379">More...</a><br /></td></tr>
<tr class="separator:a6c3e828a1b253f67f45e714c4784b379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c1afde88bb2bbc7a20aebe300798f3"><td class="memItemLeft" align="right" valign="top">tf::Pose&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a42c1afde88bb2bbc7a20aebe300798f3">Identity</a> ()</td></tr>
<tr class="memdesc:a42c1afde88bb2bbc7a20aebe300798f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Identity Pose.  <a href="#a42c1afde88bb2bbc7a20aebe300798f3">More...</a><br /></td></tr>
<tr class="separator:a42c1afde88bb2bbc7a20aebe300798f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6663d9a014bfffe92a1d9fd892040e20"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6663d9a014bfffe92a1d9fd892040e20"><td class="memTemplItemLeft" align="right" valign="top">geometry_msgs::Pose&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a6663d9a014bfffe92a1d9fd892040e20">Convert&lt; tf::Pose, geometry_msgs::Pose &gt;</a> (tf::Pose m)</td></tr>
<tr class="memdesc:a6663d9a014bfffe92a1d9fd892040e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert tf::Pose pose into an geometry_msgs::Pose pose.  <a href="#a6663d9a014bfffe92a1d9fd892040e20">More...</a><br /></td></tr>
<tr class="separator:a6663d9a014bfffe92a1d9fd892040e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17e104616c17413a4b15cefbdebadb4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af17e104616c17413a4b15cefbdebadb4"><td class="memTemplItemLeft" align="right" valign="top">geometry_msgs::Pose&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#af17e104616c17413a4b15cefbdebadb4">Convert&lt; geometry_msgs::Point, geometry_msgs::Pose &gt;</a> (geometry_msgs::Point point)</td></tr>
<tr class="memdesc:af17e104616c17413a4b15cefbdebadb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geometry_msgs::Point point into an geometry_msgs::Pose pose.  <a href="#af17e104616c17413a4b15cefbdebadb4">More...</a><br /></td></tr>
<tr class="separator:af17e104616c17413a4b15cefbdebadb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632efe009073f4921a91c59f884b1f9b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a632efe009073f4921a91c59f884b1f9b"><td class="memTemplItemLeft" align="right" valign="top">geometry_msgs::Vector3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a632efe009073f4921a91c59f884b1f9b">Convert&lt; tf::Vector3, geometry_msgs::Vector3 &gt;</a> (tf::Vector3 point)</td></tr>
<tr class="memdesc:a632efe009073f4921a91c59f884b1f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert tf::Vector3 vector translation into an geometry_msgs::Point.  <a href="#a632efe009073f4921a91c59f884b1f9b">More...</a><br /></td></tr>
<tr class="separator:a632efe009073f4921a91c59f884b1f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a16f5c64c7a6cd245c19d619fcb761"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a52a16f5c64c7a6cd245c19d619fcb761"><td class="memTemplItemLeft" align="right" valign="top">geometry_msgs::Point&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a52a16f5c64c7a6cd245c19d619fcb761">Convert&lt; tf::Vector3, geometry_msgs::Point &gt;</a> (tf::Vector3 point)</td></tr>
<tr class="separator:a52a16f5c64c7a6cd245c19d619fcb761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac571c318f402b96cd5f845fafbf59595"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac571c318f402b96cd5f845fafbf59595"><td class="memTemplItemLeft" align="right" valign="top">geometry_msgs::Vector3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#ac571c318f402b96cd5f845fafbf59595">Convert&lt; double, geometry_msgs::Vector3 &gt;</a> (double scale)</td></tr>
<tr class="memdesc:ac571c318f402b96cd5f845fafbf59595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Eigen::Vector3d translation into an geometry_msgs Vector3.  <a href="#ac571c318f402b96cd5f845fafbf59595">More...</a><br /></td></tr>
<tr class="separator:ac571c318f402b96cd5f845fafbf59595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b3311cff6ea2c05e753244a418877c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af8b3311cff6ea2c05e753244a418877c"><td class="memTemplItemLeft" align="right" valign="top">tf::Vector3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#af8b3311cff6ea2c05e753244a418877c">Convert&lt; urdf::Vector3, tf::Vector3 &gt;</a> (urdf::Vector3 v)</td></tr>
<tr class="memdesc:af8b3311cff6ea2c05e753244a418877c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert urdf::Vector into an tf vector.  <a href="#af8b3311cff6ea2c05e753244a418877c">More...</a><br /></td></tr>
<tr class="separator:af8b3311cff6ea2c05e753244a418877c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4a24f55132a0403f793a2ec790c919"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a9f4a24f55132a0403f793a2ec790c919">toDegree</a> (double ang)</td></tr>
<tr class="memdesc:a9f4a24f55132a0403f793a2ec790c919"><td class="mdescLeft">&#160;</td><td class="mdescRight">toDegree convert angle from radian to degree  <a href="#a9f4a24f55132a0403f793a2ec790c919">More...</a><br /></td></tr>
<tr class="separator:a9f4a24f55132a0403f793a2ec790c919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb07e5f58545f74ee04479c53ebb2cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5eb07e5f58545f74ee04479c53ebb2cf"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a5eb07e5f58545f74ee04479c53ebb2cf">vectorDump</a> (std::vector&lt; T &gt; v, std::string separator=&quot;,&quot;)</td></tr>
<tr class="memdesc:a5eb07e5f58545f74ee04479c53ebb2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">vectorDump to a dump of a vector to a stringstream, return string.  <a href="#a5eb07e5f58545f74ee04479c53ebb2cf">More...</a><br /></td></tr>
<tr class="separator:a5eb07e5f58545f74ee04479c53ebb2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20e6d645d0d097d8080c39595bef3e0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#ac20e6d645d0d097d8080c39595bef3e0">vectorDump</a> (std::vector&lt; double &gt; v, std::string separator, std::string format=&quot;%5.2f&quot;)</td></tr>
<tr class="memdesc:ac20e6d645d0d097d8080c39595bef3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">vectorDump of vector of doubles  <a href="#ac20e6d645d0d097d8080c39595bef3e0">More...</a><br /></td></tr>
<tr class="separator:ac20e6d645d0d097d8080c39595bef3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d129d28638a8a75a393712a684b44cd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a9d129d28638a8a75a393712a684b44cd">dumpPose</a> (tf::Pose &amp;pose)</td></tr>
<tr class="memdesc:a9d129d28638a8a75a393712a684b44cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">dumpPose takes a urdf pose and generates a string describing pose. Can be used as std::cout &lt;&lt; DumpPose(pose);  <a href="#a9d129d28638a8a75a393712a684b44cd">More...</a><br /></td></tr>
<tr class="separator:a9d129d28638a8a75a393712a684b44cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105e1c5354e8b5d3443e05cdb3357676"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a105e1c5354e8b5d3443e05cdb3357676">dumpPoseSimple</a> (tf::Pose pose)</td></tr>
<tr class="memdesc:a105e1c5354e8b5d3443e05cdb3357676"><td class="mdescLeft">&#160;</td><td class="mdescRight">DumpPoseSimple generatseriallinkrobotes string of xyz origin and rpy rotation from a tf pose.  <a href="#a105e1c5354e8b5d3443e05cdb3357676">More...</a><br /></td></tr>
<tr class="separator:a105e1c5354e8b5d3443e05cdb3357676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689263f7a53fd63ee38b84fbff4dd677"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a689263f7a53fd63ee38b84fbff4dd677"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a689263f7a53fd63ee38b84fbff4dd677">dumpEVector</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a689263f7a53fd63ee38b84fbff4dd677"><td class="mdescLeft">&#160;</td><td class="mdescRight">dumpEVector generates a debug string for an Vector. Can be used as std::cout &lt;&lt; DumpEPosition(v);  <a href="#a689263f7a53fd63ee38b84fbff4dd677">More...</a><br /></td></tr>
<tr class="separator:a689263f7a53fd63ee38b84fbff4dd677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6a61adb210c3e69e0d36a24d837012"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#ace6a61adb210c3e69e0d36a24d837012">dumpVector</a> (const tf::Vector3 &amp;v)</td></tr>
<tr class="memdesc:ace6a61adb210c3e69e0d36a24d837012"><td class="mdescLeft">&#160;</td><td class="mdescRight">dumpVector generates a debug string for an Vector. Can be used as std::cout &lt;&lt; DumpVector(v);  <a href="#ace6a61adb210c3e69e0d36a24d837012">More...</a><br /></td></tr>
<tr class="separator:ace6a61adb210c3e69e0d36a24d837012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cc3503e33d73a40c7ca79aa8c83e93"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78cc3503e33d73a40c7ca79aa8c83e93"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a78cc3503e33d73a40c7ca79aa8c83e93">dumpStdVector</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a78cc3503e33d73a40c7ca79aa8c83e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">dump std Vector generates a debug string for an Eigen Vector. Can be used as std::cout &lt;&lt; DumpEPosition(v);  <a href="#a78cc3503e33d73a40c7ca79aa8c83e93">More...</a><br /></td></tr>
<tr class="separator:a78cc3503e33d73a40c7ca79aa8c83e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4ce97df345c416a77290936072934c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a6a4ce97df345c416a77290936072934c">operator&lt;&lt;</a> (std::ostream &amp;os, tf::Pose &amp;pose)</td></tr>
<tr class="memdesc:a6a4ce97df345c416a77290936072934c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DumpPose takes a urdf pose and generates a string describing pose. Can be used as std::cout &lt;&lt; DumpPose(pose);.  <a href="#a6a4ce97df345c416a77290936072934c">More...</a><br /></td></tr>
<tr class="separator:a6a4ce97df345c416a77290936072934c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90a570a5fb487b89b370d9bac98ec22"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#ab90a570a5fb487b89b370d9bac98ec22">dumpQuaterion</a> (const tf::Quaternion &amp;rot)</td></tr>
<tr class="memdesc:ab90a570a5fb487b89b370d9bac98ec22"><td class="mdescLeft">&#160;</td><td class="mdescRight">dumpQuaterion takes a urdf quaterion and generates a string describing x,y,z,w coordinates. Can be used as std::cout &lt;&lt; DumpQuaterion(urdf::rotation);  <a href="#ab90a570a5fb487b89b370d9bac98ec22">More...</a><br /></td></tr>
<tr class="separator:ab90a570a5fb487b89b370d9bac98ec22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2bcad598aecea48826472deeb4b06e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a0d2bcad598aecea48826472deeb4b06e">dumpMatrix</a> (const tf::Matrix3x3 &amp;m)</td></tr>
<tr class="separator:a0d2bcad598aecea48826472deeb4b06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99491108c0176f5bce34fba3064cde06"><td class="memItemLeft" align="right" valign="top">sensor_msgs::JointState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a99491108c0176f5bce34fba3064cde06">emptyJointState</a> (size_t n)</td></tr>
<tr class="separator:a99491108c0176f5bce34fba3064cde06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9de027fee4ac05974a866120e153bc"><td class="memItemLeft" align="right" valign="top">sensor_msgs::JointState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#aee9de027fee4ac05974a866120e153bc">subset</a> (sensor_msgs::JointState js, size_t n)</td></tr>
<tr class="separator:aee9de027fee4ac05974a866120e153bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d8220ee5bdbaa479f88620c14d3685"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a03d8220ee5bdbaa479f88620c14d3685">subset</a> (std::vector&lt; double &gt; position, size_t n)</td></tr>
<tr class="separator:a03d8220ee5bdbaa479f88620c14d3685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc78943e193edb7e85fb9f8d980d36bd"><td class="memItemLeft" align="right" valign="top">sensor_msgs::JointState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#adc78943e193edb7e85fb9f8d980d36bd">zeroJointState</a> (size_t numjoints)</td></tr>
<tr class="separator:adc78943e193edb7e85fb9f8d980d36bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067a4a0ff9c97e09d26fd37c9ed36507"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a067a4a0ff9c97e09d26fd37c9ed36507">hasMotion</a> (sensor_msgs::JointState js)</td></tr>
<tr class="separator:a067a4a0ff9c97e09d26fd37c9ed36507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad853ff410e5b50a9501da72a3951158b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#ad853ff410e5b50a9501da72a3951158b">sCmd</a> (int i)</td></tr>
<tr class="memdesc:ad853ff410e5b50a9501da72a3951158b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sCmd string corresponding to CRCL command enum  <a href="#ad853ff410e5b50a9501da72a3951158b">More...</a><br /></td></tr>
<tr class="separator:ad853ff410e5b50a9501da72a3951158b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132d4fc736a3bfc336e367f7d2bb504c"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a132d4fc736a3bfc336e367f7d2bb504c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a132d4fc736a3bfc336e367f7d2bb504c">ToNanoseconds</a> (std::chrono::duration&lt; Rep, Period &gt; d)</td></tr>
<tr class="separator:a132d4fc736a3bfc336e367f7d2bb504c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da1b7a70f4c87ad00b543fab0fc9ea1"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a1da1b7a70f4c87ad00b543fab0fc9ea1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a1da1b7a70f4c87ad00b543fab0fc9ea1">ToSeconds</a> (std::chrono::duration&lt; Rep, Period &gt; d)</td></tr>
<tr class="separator:a1da1b7a70f4c87ad00b543fab0fc9ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2236ac02e64d233bd6b81a08b9741868"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a2236ac02e64d233bd6b81a08b9741868">dumpPoseSimple</a> (geometry_msgs::Pose pose)</td></tr>
<tr class="separator:a2236ac02e64d233bd6b81a08b9741868"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a712edb8c3f3a2dbc0cd91998da1d5e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRCS_1_1CMessageQueue.html">CMessageQueue</a>&lt; <a class="el" href="structRCS_1_1CCanonCmd.html">RCS::CCanonCmd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a712edb8c3f3a2dbc0cd91998da1d5e80">cmds</a></td></tr>
<tr class="memdesc:a712edb8c3f3a2dbc0cd91998da1d5e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">cmds is the queue for CRCL XML commands that have been translated from CRCL into ROS equivalent custom command message.  <a href="#a712edb8c3f3a2dbc0cd91998da1d5e80">More...</a><br /></td></tr>
<tr class="separator:a712edb8c3f3a2dbc0cd91998da1d5e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a3ddc7a6d348cb7aff19003fedf713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRCS_1_1CCanonWorldModel.html">CCanonWorldModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#a95a3ddc7a6d348cb7aff19003fedf713">wm</a></td></tr>
<tr class="memdesc:a95a3ddc7a6d348cb7aff19003fedf713"><td class="mdescLeft">&#160;</td><td class="mdescRight">wm contains the ROS representation of the curfrent robot world model.  <a href="#a95a3ddc7a6d348cb7aff19003fedf713">More...</a><br /></td></tr>
<tr class="separator:a95a3ddc7a6d348cb7aff19003fedf713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f509607a77ccafda9341240ab36d64"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRCS.html#ad3f509607a77ccafda9341240ab36d64">pscale</a> =1.0</td></tr>
<tr class="separator:ad3f509607a77ccafda9341240ab36d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace Conversion provides some utilities to convert from one representation into another. Representations include tf, Eigen::Affine3d, std::vector, geometry_msgs::Pose, geometry_msgs::Point, and CRCL. </p>
<p>Clearly there may be faster const references, but they require special line to convert, cannot be done in line since you cannot pass a const reference to a constructor on the stack in g++ unless you override a warning.</p>
<p>For g++, compilation would be faster if these conversion routines were placed in source file (cpp) OR you used precompiled header in g++. here is a "silent" error when exceeding precompiled header limits in g++. (Or was at one time). </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a7bc73372e6a89bb37b562bdd72cf3a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRCS_1_1CPriorityMessageQueue.html">RCS::CPriorityMessageQueue</a>&lt;<a class="el" href="structcrcl__rosmsgs_1_1CrclCommandMsg.html">crcl_rosmsgs::CrclCommandMsg</a>, <a class="el" href="structRCS_1_1compareCrclId.html">RCS::compareCrclId</a>&gt; <a class="el" href="namespaceRCS.html#a7bc73372e6a89bb37b562bdd72cf3a6e">RCS::CrclMessageQueue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a161197f1bc13b855025b237801dea8eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::chrono::high_resolution_clock::time_point <a class="el" href="namespaceRCS.html#a161197f1bc13b855025b237801dea8eb">RCS::RCS_Time</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a01c220bdfe1b529b0925d3c9d443b7c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* RCS::RCS_TIMERFUNC) (void *_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a37ac16f6e009553aa5f363a3c3949861"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To RCS::Convert </td>
          <td>(</td>
          <td class="paramtype">From&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty conversion of type from into type to. If called, asserts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>is defined in the template corresponding to the "From" typename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>to is defined in the template corresponding "To" typename </dd></dl>

</div>
</div>
<a class="anchor" id="ac571c318f402b96cd5f845fafbf59595"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geometry_msgs::Vector3 <a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">RCS::Convert</a>&lt; double, geometry_msgs::Vector3 &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert Eigen::Vector3d translation into an geometry_msgs Vector3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>is defined as a Eigen::Vector3d. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geometry_msgs :Vector3e </dd></dl>

</div>
</div>
<a class="anchor" id="af17e104616c17413a4b15cefbdebadb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geometry_msgs::Pose <a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">RCS::Convert</a>&lt; geometry_msgs::Point, geometry_msgs::Pose &gt; </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Point&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert geometry_msgs::Point point into an geometry_msgs::Pose pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>geometry_msgs::Point is translation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geometry_msgs::Pose pose. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4d6e450ecf2c5116230ae386a2c9ad5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Pose <a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">RCS::Convert</a>&lt; geometry_msgs::Pose, tf::Pose &gt; </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert geometry_msgs::Pose into tf::Pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pose</td><td>is copy constructor of geometry_msgs::Pose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tf::Pose </dd></dl>

</div>
</div>
<a class="anchor" id="a6663d9a014bfffe92a1d9fd892040e20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geometry_msgs::Pose <a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">RCS::Convert</a>&lt; tf::Pose, geometry_msgs::Pose &gt; </td>
          <td>(</td>
          <td class="paramtype">tf::Pose&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert tf::Pose pose into an geometry_msgs::Pose pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>is a tf::Pose transform matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geometry_msgs::Pose pose </dd></dl>

</div>
</div>
<a class="anchor" id="adb1d0e845c7aca5f94ee9ef547cd312d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Vector3 <a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">RCS::Convert</a>&lt; tf::Pose, tf::Vector3 &gt; </td>
          <td>(</td>
          <td class="paramtype">tf::Pose&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert tf::Pose into tf::Vector3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is tf::Pose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tf::Vector3 </dd></dl>

</div>
</div>
<a class="anchor" id="a7e75302cbdd498437aaadbb62d451d17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Pose <a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">RCS::Convert</a>&lt; tf::Quaternion, tf::Pose &gt; </td>
          <td>(</td>
          <td class="paramtype">tf::Quaternion&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert tf::Quaternion into tf::Pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>rotation is converted into a tf::Pose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tf::Pose </dd></dl>

</div>
</div>
<a class="anchor" id="a52a16f5c64c7a6cd245c19d619fcb761"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geometry_msgs::Point <a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">RCS::Convert</a>&lt; tf::Vector3, geometry_msgs::Point &gt; </td>
          <td>(</td>
          <td class="paramtype">tf::Vector3&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a632efe009073f4921a91c59f884b1f9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geometry_msgs::Vector3 <a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">RCS::Convert</a>&lt; tf::Vector3, geometry_msgs::Vector3 &gt; </td>
          <td>(</td>
          <td class="paramtype">tf::Vector3&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert tf::Vector3 vector translation into an geometry_msgs::Point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>is translation defined as a tf::Vector3 vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geometry_msgs::Point vector </dd></dl>

</div>
</div>
<a class="anchor" id="a7f8beb14a607d0761435e21f8aaae004"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Pose <a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">RCS::Convert</a>&lt; tf::Vector3, tf::Pose &gt; </td>
          <td>(</td>
          <td class="paramtype">tf::Vector3&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert tf::Vector3 into tf::Pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>is translation is converted into a tf::Pose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tf::Pose </dd></dl>

</div>
</div>
<a class="anchor" id="af8b3311cff6ea2c05e753244a418877c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Vector3 <a class="el" href="namespaceRCS.html#a37ac16f6e009553aa5f363a3c3949861">RCS::Convert</a>&lt; urdf::Vector3, tf::Vector3 &gt; </td>
          <td>(</td>
          <td class="paramtype">urdf::Vector3&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert urdf::Vector into an tf vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is a urdf::Vector3t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tf::Vector3 vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aeaeace0f93a957fe258b4b2ba64c3062"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Pose RCS::ConvertDblVectorTf </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7c180fb111c739f218802a66eb6b2c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;To&gt; RCS::ConvertStringVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>From</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a list of std vector type string into a vector of doubles. </p>
<dl class="section return"><dt>Returns</dt><dd>converted set of std::vector&lt;double&gt; returned if error assume 0 put into array. Convert a list of std vector type string into a vector of Type template T </dd>
<dd>
converted vector </dd></dl>

</div>
</div>
<a class="anchor" id="a759bab14f332371a1810654242cf3f2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Pose RCS::CreatePose </td>
          <td>(</td>
          <td class="paramtype">tf::Vector3&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Pose from a axis and angle rotation representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>is the unit vector to rotation around. </td></tr>
    <tr><td class="paramname">angle</td><td>is the angle of rotation in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tf::Pose </dd></dl>

</div>
</div>
<a class="anchor" id="a647347930fde84748762563d582075fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Pose RCS::CreateRPYPose </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CreateRPYPose taks array of double and create a tf::Pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ds</td><td>is a std array of 6 doubles to create pose (rpy + xyz). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tf::Pose NOTE: Constructor from Euler angles </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yaw</td><td>Angle around Y unless TF_EULER_DEFAULT_ZYX defined then Z </td></tr>
    <tr><td class="paramname">pitch</td><td>Angle around X unless TF_EULER_DEFAULT_ZYX defined then Y </td></tr>
    <tr><td class="paramname">roll</td><td>Angle around Z unless TF_EULER_DEFAULT_ZYX defined then X tf::Quaternion(const tfScalar&amp; yaw, const tfScalar&amp; pitch, const tfScalar&amp; roll) <b>attribute</b>((deprecated)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a689263f7a53fd63ee38b84fbff4dd677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCS::dumpEVector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dumpEVector generates a debug string for an Vector. Can be used as std::cout &lt;&lt; DumpEPosition(v); </p>

</div>
</div>
<a class="anchor" id="a0d2bcad598aecea48826472deeb4b06e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCS::dumpMatrix </td>
          <td>(</td>
          <td class="paramtype">const tf::Matrix3x3 &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d129d28638a8a75a393712a684b44cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCS::dumpPose </td>
          <td>(</td>
          <td class="paramtype">tf::Pose &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dumpPose takes a urdf pose and generates a string describing pose. Can be used as std::cout &lt;&lt; DumpPose(pose); </p>

</div>
</div>
<a class="anchor" id="a2236ac02e64d233bd6b81a08b9741868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCS::dumpPoseSimple </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a105e1c5354e8b5d3443e05cdb3357676"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCS::dumpPoseSimple </td>
          <td>(</td>
          <td class="paramtype">tf::Pose&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DumpPoseSimple generatseriallinkrobotes string of xyz origin and rpy rotation from a tf pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pose</td><td>tf pose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string </dd></dl>

</div>
</div>
<a class="anchor" id="ab90a570a5fb487b89b370d9bac98ec22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCS::dumpQuaterion </td>
          <td>(</td>
          <td class="paramtype">const tf::Quaternion &amp;&#160;</td>
          <td class="paramname"><em>rot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dumpQuaterion takes a urdf quaterion and generates a string describing x,y,z,w coordinates. Can be used as std::cout &lt;&lt; DumpQuaterion(urdf::rotation); </p>

</div>
</div>
<a class="anchor" id="a78cc3503e33d73a40c7ca79aa8c83e93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCS::dumpStdVector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dump std Vector generates a debug string for an Eigen Vector. Can be used as std::cout &lt;&lt; DumpEPosition(v); </p>

</div>
</div>
<a class="anchor" id="ace6a61adb210c3e69e0d36a24d837012"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCS::dumpVector </td>
          <td>(</td>
          <td class="paramtype">const tf::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dumpVector generates a debug string for an Vector. Can be used as std::cout &lt;&lt; DumpVector(v); </p>

</div>
</div>
<a class="anchor" id="a99491108c0176f5bce34fba3064cde06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sensor_msgs::JointState RCS::emptyJointState </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a067a4a0ff9c97e09d26fd37c9ed36507"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RCS::hasMotion </td>
          <td>(</td>
          <td class="paramtype">sensor_msgs::JointState&#160;</td>
          <td class="paramname"><em>js</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a42c1afde88bb2bbc7a20aebe300798f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Pose RCS::Identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Identity Pose. </p>
<dl class="section return"><dt>Returns</dt><dd>tf::Pose </dd></dl>

</div>
</div>
<a class="anchor" id="a6a4ce97df345c416a77290936072934c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; RCS::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tf::Pose &amp;&#160;</td>
          <td class="paramname"><em>pose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DumpPose takes a urdf pose and generates a string describing pose. Can be used as std::cout &lt;&lt; DumpPose(pose);. </p>

</div>
</div>
<a class="anchor" id="a6153c96ec882b3eeb738088b41d42aee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Quaternion RCS::Rpy2Quaternion </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c3e828a1b253f67f45e714c4784b379"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Quaternion RCS::RPYDegrees </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Quaternion from a rpy rotation representation designated in degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roll</td><td>rotation around x axis in degrees. </td></tr>
    <tr><td class="paramname">pitch</td><td>rotation around y axis in degrees. </td></tr>
    <tr><td class="paramname">yaw</td><td>rotation around z axis in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tf::Quaternion </dd></dl>

</div>
</div>
<a class="anchor" id="acf5e15676de18c49b48ed17eebe80339"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Quaternion RCS::RPYRadians </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Quaternion from a rpy rotation representation designated in radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roll</td><td>rotation around x axis in radians. </td></tr>
    <tr><td class="paramname">pitch</td><td>rotation around y axis in radians. </td></tr>
    <tr><td class="paramname">yaw</td><td>rotation around z axis in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tf::Quaternion </dd></dl>

</div>
</div>
<a class="anchor" id="a606c365be7883a31a4dbf241b3e0c0a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; RCS::ScaleVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>goaljts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>multiplier</em> = <code>M_PI&#160;/&#160;180.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a list of std vector type T from degrees to radians Change template from typep into double conversion factor. you can't use float literals as template parameters. </p>

</div>
</div>
<a class="anchor" id="ad853ff410e5b50a9501da72a3951158b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* RCS::sCmd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sCmd string corresponding to CRCL command enum </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the CRCL command id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of enumeration </dd></dl>

</div>
</div>
<a class="anchor" id="aee9de027fee4ac05974a866120e153bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sensor_msgs::JointState RCS::subset </td>
          <td>(</td>
          <td class="paramtype">sensor_msgs::JointState&#160;</td>
          <td class="paramname"><em>js</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a03d8220ee5bdbaa479f88620c14d3685"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; RCS::subset </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9f4a24f55132a0403f793a2ec790c919"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double RCS::toDegree </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ang</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>toDegree convert angle from radian to degree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ang</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a132d4fc736a3bfc336e367f7d2bb504c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double RCS::ToNanoseconds </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84f28269c28731c0ebdb78bb23fa428a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; RCS::ToRadianVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>goaljts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a list of std vector type T from degrees to radians Change template from typep into double conversion factor. you can't use float literals as template parameters. </p>

</div>
</div>
<a class="anchor" id="a1da1b7a70f4c87ad00b543fab0fc9ea1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double RCS::ToSeconds </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac696d9ef9c4058c180c13bdb3a867118"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; RCS::ToVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ToVector calling parameters MUST match e.g., double or long depending on template, OR wont work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of items to push into std vector. </td></tr>
    <tr><td class="paramname">...</td><td>list of n template type items </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std vector of type T </dd></dl>

</div>
</div>
<a class="anchor" id="a5eb07e5f58545f74ee04479c53ebb2cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCS::vectorDump </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vectorDump to a dump of a vector to a stringstream, return string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector of template type T </td></tr>
    <tr><td class="paramname">separator</td><td>separator between type ostream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std string of stringstream </dd></dl>

</div>
</div>
<a class="anchor" id="ac20e6d645d0d097d8080c39595bef3e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RCS::vectorDump </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;%5.2f&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vectorDump of vector of doubles </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector of doubles </td></tr>
    <tr><td class="paramname">separator</td><td>separator between double outputs </td></tr>
    <tr><td class="paramname">format</td><td>string to format double, default %5.2f </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std string from stringstream conversion </dd></dl>

</div>
</div>
<a class="anchor" id="adc78943e193edb7e85fb9f8d980d36bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sensor_msgs::JointState RCS::zeroJointState </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numjoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a712edb8c3f3a2dbc0cd91998da1d5e80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRCS_1_1CMessageQueue.html">CMessageQueue</a>&lt; <a class="el" href="structRCS_1_1CCanonCmd.html">RCS::CCanonCmd</a> &gt; RCS::cmds</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cmds is the queue for CRCL XML commands that have been translated from CRCL into ROS equivalent custom command message. </p>

</div>
</div>
<a class="anchor" id="ad3f509607a77ccafda9341240ab36d64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double RCS::pscale =1.0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a95a3ddc7a6d348cb7aff19003fedf713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRCS_1_1CCanonWorldModel.html">CCanonWorldModel</a> RCS::wm</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wm contains the ROS representation of the curfrent robot world model. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
