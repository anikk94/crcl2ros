<HTML>
<BODY>
    <H1> CRCL2ROS API DOCUMENTATION </H1>

To tackle the problem of agility performance across many robotic systems, the Canonical Robot Command Language (CRCL) was developed at the National Institute of Standards and Technology (NIST) as a robot communication standard. CRCL itself is an XML messaging specification that focuses on the domain of industrial robotics control as a special case of an overall ontology for automation.  For simulation, NIST has previously used CRCL to allow the APRS lab Java-based “aprs framework” software to communicate planning and control to the C++/Python based Gazebo robot kitting simulations as opposed to planning and control of the actual robots in the APRS kitting lab.  The previous CRCL to Gazebo simulation work relied on the gomotion robot motion planning tools while the new software tools relied exclusively on ROS, specifically moveit!, for robot motion planning. ROS is a popular open-source robotics environment supported by  a large community of users and developers who have adapted ROS to support a wide range of robots, sensors, and grippers.

The initial focus of the CRCL to ROS/Gazebo work was to enable the use multi-agent robot planning computer languages to program one or more kitting robots using CRCL for command and control. Of note, the existing CRCL XML schema was extended to provide status describing kitting models (gears, trays, kits, etc.) as well as inferences about the kitting models (e.g., a gear located in a supply tray slot) to accommodate advanced reasoning.  The CRCL 2 ROS code has been made available publicly on github and can be found at https://github.com/usnistgov/crcl2ros. Depending on deployment, CRCL commands and status can be a simulated Gazebo kitting setup or use ROS for actual robot planning and control.

<UL>
    <LI><a href="./doxygen/html/index.html"> CRCL2ROS API Code Documentation</a></LI>
</UL>

<H1> CRCL XSD DOCUMENTATION </H1>
    CRCL is an XML robot language for communication
    whose purpose is to standardize robot motion control
    (specifically grasping).  It sits above fieldbus communication
    but below planning level (e.g., PDDL, Redhat Optaplanner –
    two agility planners we use).  CRCL compares to  ROS topics
    (both moveit and joint level) but is more centralized under
    one XSD schema and is more portable (you don’t need ROS).

    CrclApp provides a ROS motion planning to Gazebo simulation of the APRS lab that incorporates CRCL (running on Ubuntu 16.04/ROS Kinetic/Gazebo 7) found
    <a href="https://github.com/usnistgov/crcl2ros"> here </a>.
    <p>
        A breakdown of the CRCL XML schema (XSD) is presented below using XSLT to extract the
        the annotated comments per XSD definition. Below, CRCLCommands and CRCLStatus highlight
        the major command/status areas.
    </p>
    <UL>
        <LI><a href="./crcl/CRCLCommandInstance.html"> CRCLCommandInstance </a></LI>
        <LI><a href="./crcl/CRCLCommands.html"> CRCLCommands</a></LI>
        <LI><a href="./crcl/CRCLProgramInstance.html"> CRCLProgramInstance</a></LI>
        <LI><a href="./crcl/CRCLStatus.html"> CRCLStatus</a></LI>
        <LI><a href="./crcl/DataPrimitives.html"> DataPrimitives</a></LI>
    </UL>
There is also documentation generated by javadoc that is used by the Java CRCL application. It
can be found below.
<UL>
    <LI><a href="./crclbase/index.html"> java crclbase jar</a></LI>
</UL>

</BODY>
</HTML>